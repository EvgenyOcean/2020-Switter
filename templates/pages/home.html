{% extends 'pages/base.html' %}

{% block content %}

<div class="row my-3">
  <div class="col text-center">
    <h1>Hello from the home page!</h1>
  </div>
</div>

<!-- Hardcoded form, yet will be backend validated, because we use exactly the same names as in the django form -->
<div class="row">
  <div class="col-10 col-md-6 mx-auto mb-3">
    <form action="add-tweet" method="POST" class="form" name="add-tweet">
      {% csrf_token %}
      <input type="hidden" name="redirect" value="/">
      <div class="form-group d-none" id="errs-container"></div>
      <textarea name="content" class="form-control" placeholder="Any thoughts?" required></textarea>
      <input type="submit" value="Add" class="btn btn-success mt-2">
    </form>
  </div>
</div>

<div class="row tweets px-4">
  Loading...
</div>

<script>
  
  let tweetForm = document.forms['add-tweet'];
  tweetForm.addEventListener('submit', handleAddTweet);
  
  // why we can't go on with a simple submit? 
  // 1. Because submit will cause page reload 
  // 2. Because we want to send an ajax request and get json as a response, without any redirects, which basically complements the first statement.
  function handleAddTweet(e){
    e.preventDefault();
    let form = new FormData(e.target); //allows to send files; and extracts name - value pairs
    fetch('add-tweet', {
      method: 'POST',
      headers: {
        'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: form,
    }).then(response => {
      if ([200, 201].includes(response.status)){
        toggleDisplayErrs(); // to hide errors div
        response.json().then(data => {
          let currentDiv = htmlFromTweet(data);
          tweetsDiv.insertAdjacentElement('afterbegin', currentDiv);
          e.target.elements['content'].value = ''; //or myForm.reset()
        }).catch(err => {console.log(err)})
      } else if (response.status === 400) { //validation error
        response.json().then(errData => {
          console.log(errData);
          // extracting all errors, creating a div for each error, prepending to the page
          let allErrs = [];
          for (let subject of Object.getOwnPropertyNames(errData)){
            for (let err of errData[subject]){
              allErrs.push(err);
            }
          }
          let errsDiv = document.createElement('div');
          // later on, you will just make divs using map in react
          for (let err of allErrs){
            let errDiv = document.createElement('div');
            errDiv.classList.add('alert', 'alert-danger');
            errDiv.textContent = err;
            errsDiv.append(errDiv);
          }
          toggleDisplayErrs(errsDiv);
        }).catch(err => {console.log(err)})
      } else if (response.status === 403){ //permission denied
        response.json().then(errData => {
          console.log(errData);
          // window.location = '/login'; // redirecting to the login page (a lil hardcoded)
        })
      } 
    }).catch(err => {console.log('You shall see me not!')});
  }

  //to render or hide err div
  function toggleDisplayErrs(errsDiv=null){
    //get the container which display is none by default (d-none bootstrap class)
    let errsDivContainer = document.getElementById('errs-container');
    errsDivContainer.innerHTML = ''; //remove all the prev errors 
    if (errsDiv){ // if any errs display the errs container and append errs divs
      errsDivContainer.classList.remove('d-none');
      errsDivContainer.append(errsDiv);
    } else { // d-none again
      errsDivContainer.classList.add('d-none');
    }
  }

  //function to handle btnLike click 
  function handleLikeClick(tweetId, likesAmount){
    console.log(tweetId, likesAmount);
  }

  // parsing the data into html elements
  function htmlFromTweet(currentTweet){
    //creating elements and adding classes and ids
    let currentDiv = document.createElement('div'); 
    let likeBtn = document.createElement('button');
    currentDiv.append(document.createElement('p'));
    currentDiv.classList.add('col-12', 'col-md-10', 'col-lg-8', 'mx-auto', 'border', 'border-primary', 'py-2','mb-4', 'tweet');
    currentDiv.id = `tweet-${currentTweet.id}`;
    likeBtn.classList.add('btn', 'btn-primary');
    likeBtn.textContent = `Like ${currentTweet.likesAmount}`;
    
    //adding click handlers
    likeBtn.onclick = handleLikeClick.bind(null, currentTweet.id, currentTweet.likesAmount);

    //inserting created elements onto the page
    currentDiv.firstElementChild.insertAdjacentText('beforeend', currentTweet.content); //don't trust user input, so content should be paste as string only

    currentDiv.append(likeBtn);
    return currentDiv
  }

  //loading tweets as a function, now we can call this function whenever it's necessary to update all the tweets
  function loadTweets(containerEl){
    fetch('/tweets')
      .then(response => {
        if (response.ok){
          return response.json()
        } else {
          throw new Error('Something went wrong!');
        }
      })
      .then(data => {
        // getting tweets from db and inserting them into the page, dynamically creating divs and paragraphs for tweets content fields. 
        for (let i=0; i<data.length; i++){
          let currentTweet = data[i]; // getting an object with a tweet info
          let currentDiv = htmlFromTweet(currentTweet);
          containerEl.append(currentDiv); //adding the tweet to a desired div on a page
        }
        containerEl.firstChild.remove(); //just removing the loading text
      })
      .catch(err => {
        console.log(err.message);
      })
  }

  let tweetsDiv = document.querySelector('.tweets');
  loadTweets(tweetsDiv);
</script>
{% endblock %}