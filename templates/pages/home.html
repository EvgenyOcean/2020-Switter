{% extends 'pages/base.html' %}

{% block content %}

<div id="root"></div>

<div class="row my-3 d-none">
  <div class="col text-center">
    <h1>Hello from the home page!</h1>
  </div>
</div>

<!-- Hardcoded form, yet will be backend validated, because we use exactly the same names as in the django form -->
<div class="row d-none">
  <div class="col-10 col-md-6 mx-auto mb-3">
    <form action="api/tweets/add-tweet" method="POST" class="form" name="add-tweet">
      {% csrf_token %}
      <input type="hidden" name="redirect" value="/">
      <div class="form-group d-none" id="errs-container"></div>
      <textarea name="content" class="form-control" placeholder="Any thoughts?" required></textarea>
      <input type="submit" value="Add" class="btn btn-success mt-2">
    </form>
  </div>
</div>

<div class="row tweets px-4 d-none">
  Loading...
</div>

<script>
  
  let tweetForm = document.forms['add-tweet'];
  tweetForm.addEventListener('submit', handleAddTweet);
  
  // why we can't go on with a simple submit? 
  // 1. Because submit will cause page reload 
  // 2. Because we want to send an ajax request and get json as a response, without any redirects, which basically complements the first statement.
  function handleAddTweet(e){
    e.preventDefault();
    let form = new FormData(e.target); //allows to send files; and extracts name - value pairs
    fetch('api/tweets/add-tweet', {
      method: 'POST',
      headers: {
        'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest',
        'X-Requested-With': 'XMLHttpRequest',
      },
      body: form,
    }).then(response => {
      if ([200, 201].includes(response.status)){
        toggleDisplayErrs(); // to hide errors div
        response.json().then(data => {
          let currentDiv = htmlFromTweet(data);
          tweetsDiv.insertAdjacentElement('afterbegin', currentDiv);
          e.target.elements['content'].value = ''; //or myForm.reset()
        }).catch(err => {console.log(err)})
      } else if (response.status === 400) { //validation error
        response.json().then(errData => {
          console.log(errData);
          // extracting all errors, creating a div for each error, prepending to the page
          let allErrs = [];
          for (let subject of Object.getOwnPropertyNames(errData)){
            for (let err of errData[subject]){
              allErrs.push(err);
            }
          }
          let errsDiv = document.createElement('div');
          // later on, you will just make divs using map in react
          for (let err of allErrs){
            let errDiv = document.createElement('div');
            errDiv.classList.add('alert', 'alert-danger');
            errDiv.textContent = err;
            errsDiv.append(errDiv);
          }
          toggleDisplayErrs(errsDiv);
        }).catch(err => {console.log(err)})
      } else if (response.status === 403){ //permission denied
        response.json().then(errData => {
          console.log(errData);
          // window.location = '/login'; // redirecting to the login page (a lil hardcoded)
        })
      } 
    }).catch(err => {console.log('You shall see me not!')});
  }

  //function to handle likes and retweets 
  function handleTweetAction(tweetId, action, e){
    data = {action: action};
    fetch(`api/tweets/tweet-action/${tweetId}`, {
      method: 'POST', 
      headers: {
        'Content-Type': 'application/json',
        'HTTP_X_REQUESTED_WITH': 'XMLHttpRequest',
        'X-Requested-With': 'XMLHttpRequest',
        'X-CSRFToken': getCookie('csrftoken'),
      },
      body: JSON.stringify(data),
    }).then(response => {
        if (response.ok){
          e.target.classList.toggle('bg-info'); //jff for now
          return response.json();
        } else {
          throw new Error('something went wrong!');
        }
      })
      .then(data => {
        console.log(data);
        // just to update UI without react
        if (action === 'like'){
          e.target.textContent = `Like ${data.likes.likes}`;
        } else {
          tweetsDiv.innerHTML = 'Loading...';
          loadTweets(tweetsDiv);
        }
      })
      .catch(err => {
        console.log(err);
      })
  }

  // parsing the data into html elements
  function htmlFromTweet(currentTweet){
    //creating elements and adding classes and ids
    // console.log(currentTweet);
    let currentDiv = document.createElement('div'); 

    //handeling btns
    let likeBtn = createBtn(currentTweet, 'like');
    let retweetBtn = createBtn(currentTweet, 'retweet');
    let btnsGroupDiv = document.createElement('div'); 
    btnsGroupDiv.classList.add('btn-group'); 
    btnsGroupDiv.setAttribute('role', 'group');
    btnsGroupDiv.append(likeBtn, retweetBtn);

    currentDiv.append(document.createElement('p'));
    currentDiv.classList.add('col-12', 'col-md-10', 'col-lg-8', 'mx-auto', 'border', 'border-primary', 'py-2','mb-4', 'tweet');
    currentDiv.id = `tweet-${currentTweet.id}`;

    //inserting created elements onto the page
    currentDiv.firstElementChild.insertAdjacentText('beforeend', currentTweet.content); //don't trust user input, so content should be paste as string only

    currentDiv.append(btnsGroupDiv);
    return currentDiv
  }

  //loading tweets as a function, now we can call this function whenever it's necessary to update all the tweets
  function loadTweets(containerEl){
    fetch('api/tweets')
      .then(response => {
        if (response.ok){
          return response.json()
        } else {
          throw new Error('Something went wrong!');
        }
      })
      .then(data => {
        // getting tweets from db and inserting them into the page, dynamically creating divs and paragraphs for tweets content fields. 
        for (let i=0; i<data.length; i++){
          let currentTweet = data[i]; // getting an object with a tweet info
          let currentDiv = htmlFromTweet(currentTweet);
          containerEl.append(currentDiv); //adding the tweet to a desired div on a page
        }
        containerEl.firstChild.remove(); //just removing the loading text
      })
      .catch(err => {
        console.log(err.message);
      })
  }

  let tweetsDiv = document.querySelector('.tweets');
  loadTweets(tweetsDiv);


  // ADDITIONAL FUNCITONS 
  function createBtn(currentTweet, btnType){
    if (btnType === 'like'){
      let likeBtn = document.createElement('button');
      likeBtn.classList.add('btn', 'btn-primary');
      likeBtn.textContent = `Like ${currentTweet.likes.likes}`;
      //adding click handlers
      likeBtn.onclick = handleTweetAction.bind(null, currentTweet.id, 'like');
      return likeBtn
    } else if (btnType === 'retweet'){
      let retweetBtn = document.createElement('button');
      retweetBtn.classList.add('btn', 'btn-outline-info');
      retweetBtn.textContent = `Retweet`;
      //adding click handlers
      retweetBtn.onclick = handleTweetAction.bind(null, currentTweet.id, 'retweet');
      return retweetBtn
    }
  }

   //to render or hide err div
  function toggleDisplayErrs(errsDiv=null){
    //get the container which display is none by default (d-none bootstrap class)
    let errsDivContainer = document.getElementById('errs-container');
    errsDivContainer.innerHTML = ''; //remove all the prev errors 
    if (errsDiv){ // if any errs display the errs container and append errs divs
      errsDivContainer.classList.remove('d-none');
      errsDivContainer.append(errsDiv);
    } else { // d-none again
      errsDivContainer.classList.add('d-none');
    }
  }


  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
</script>
{% endblock %}